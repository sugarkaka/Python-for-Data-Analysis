# 创建ndarray
data1 = [6, 7.5, 8, 3]
arr1 = np.array(data1)
arr1

data2 = [[1, 2, 3, 4], [5, 6, 7, 8]]
arr2 = np.array(data2)
arr2

arr2.shape 
out：(2, 4)
arr2.ndim 
out: 2

arr1.dtype 

# 创建指定长度全为0或1的数组
np.zeros(10)
np.zeros(2)
np.ones(2)

# 创建一个正方的NN矩阵
np.eye(2)

# arange 函数是内置函数range的数组版
np.arange(6)
out: array([0, 1, 2, 3, 4, 5])

# 可以通过astype方法转换dtype
arr = np.array([1, 2, 3, 4])
arr.dtype 
out: dtype('int64')

float_art = arr.astype(np.float64)


# 可以在创建时制定数据类型
arr1 = np.array([1, 2, 3], dtype = np.float64)
arr2 = np.array([1, 2, 3], dtype = np.int32)

# 数组的dtype还有另外的用法如
int_array = np.array(10)
caliber = np.array([.22, .26, .357, .380, .44, .50], dtype = np.float64)

int_array.astype(caliber.dtype)

# 数组可以让你不用编写循环就可以对数据执行批量运算
arr = np.array([1, 2, 3], [4, 5, 6])
arr * arr
arr - arr
arr / arr

# 布尔型索引
names = np.array(['bob', 'will', 'bob', 'joe', 'will', 'joe'])
data = randn(7, 4)
names
data

names = 'bob'
data[names = 'bob']
data[names = 'bob', 3]
data[names = 'bob', 2:]

# 也可以用& | 进行布尔运算
mask = (names == 'bob') | (names = 'will')
data[mask]

# 将Data中所有负值设为0
data[data < 0] = 0

# 花式索引
arr = np.empty((8, 4))
for i in range(8):
    arr[i] = i

# 以特定的顺序选取子集
arr[[4, 3, 0, 6]]

arr = np.arange(32).reshape((8, 4))
arr
arr[np.ix_([1, 5, 7, 2], [0, 3, 1, 2])]

# 数组的转置
arr = np.arange(15).reshape((5, 3))
arr.T
np.dot(arr.T, arr)

# 通用函数
arr = anp.arange(10)
np.sqrt(arr)

x = randn(8)
y = randn(8)
np.maximum(x, y)
