# 创建ndarray
data1 = [6, 7.5, 8, 3]
arr1 = np.array(data1)
arr1

data2 = [[1, 2, 3, 4], [5, 6, 7, 8]]
arr2 = np.array(data2)
arr2

arr2.shape 
out：(2, 4)
arr2.ndim 
out: 2

arr1.dtype 

# 创建指定长度全为0或1的数组
np.zeros(10)
np.zeros(2)
np.ones(2)

# 创建一个正方的NN矩阵
np.eye(2)

# arange 函数是内置函数range的数组版
np.arange(6)
out: array([0, 1, 2, 3, 4, 5])

# 可以通过astype方法转换dtype
arr = np.array([1, 2, 3, 4])
arr.dtype 
out: dtype('int64')

float_art = arr.astype(np.float64)


# 可以在创建时制定数据类型
arr1 = np.array([1, 2, 3], dtype = np.float64)
arr2 = np.array([1, 2, 3], dtype = np.int32)

# 数组的dtype还有另外的用法如
int_array = np.array(10)
caliber = np.array([.22, .26, .357, .380, .44, .50], dtype = np.float64)

int_array.astype(caliber.dtype)

# 数组可以让你不用编写循环就可以对数据执行批量运算
arr = np.array([1, 2, 3], [4, 5, 6])
arr * arr
arr - arr
arr / arr

# 布尔型索引
names = np.array(['bob', 'will', 'bob', 'joe', 'will', 'joe'])
data = randn(7, 4)
names
data

names = 'bob'
data[names = 'bob']
data[names = 'bob', 3]
data[names = 'bob', 2:]

# 也可以用& | 进行布尔运算
mask = (names == 'bob') | (names = 'will')
data[mask]

# 将Data中所有负值设为0
data[data < 0] = 0

# 花式索引
arr = np.empty((8, 4))
for i in range(8):
    arr[i] = i

# 以特定的顺序选取子集
arr[[4, 3, 0, 6]]

arr = np.arange(32).reshape((8, 4))
arr
arr[np.ix_([1, 5, 7, 2], [0, 3, 1, 2])]

# 数组的转置
arr = np.arange(15).reshape((5, 3))
arr.T
np.dot(arr.T, arr)

# 通用函数
arr = anp.arange(10)
np.sqrt(arr)

x = randn(8)
y = randn(8)
np.maximum(x, y)

points = np.arange(-5, 5, 0.01)
xs, ys = np.meshgrid(points, points)
ys

import matplotlib.pyplot as plt
z = np.sqrt(xs ** 2 + ys ** 2)
z 

plt.imshow(z, cmap = plt.cm.gray); plt.colorbar()


xarr = np.array([1.1, 1.2, 1.3, 1.4, 1.5])
yarr = np.array([2.1, 2.2, 2.3, 2.4, 2.5])
cond = np.array([True, False, True, True, False])

result = [(x if c else y)
for x, y, c in zip(xarr, yarr, cond)]
result

result = np.where(cond, xarr, yarr)
result

# 利用np.where 替换数据
arr = randn(4, 4)
np.where(arr >0, 2, -2)
np.where(arr >0, 2, arr)

result = []
for i in range(n):
    if cond1[i] and cond2[i]:
	    result.append(0)
	elif cond1[i]:
	    result.append(1)
	elif cond2[i]:
	    result.append(2)
	else:
	    result.append(3)
		
result = 1 * (cond1 - cond2) + 2* (cond2 & - cond1) + 3 * -(cond1 | cond2)
